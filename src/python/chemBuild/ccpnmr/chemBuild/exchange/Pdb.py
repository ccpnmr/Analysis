from re import match

from ccpnmr.chemBuild.general.Constants import LINK, AROMATIC

from ccpnmr.chemBuild.model.Compound import Compound
from ccpnmr.chemBuild.model.Variant import Variant
from ccpnmr.chemBuild.model.VarAtom import VarAtom
from ccpnmr.chemBuild.model.Atom import Atom
from ccpnmr.chemBuild.model.AtomGroup import AtomGroup
from ccpnmr.chemBuild.model.Bond import Bond


PDB_FORMAT = '%-6.6s%5.1d %4.4s%s%s %s%4.1d%s   %8.3f%8.3f%8.3f%6.2f%6.2f          %2.2s%2.2s'
HETATM = 'HETATM'

"""
COLUMNS        DATA  TYPE    FIELD        DEFINITION
-------------------------------------------------------------------------------------
 1 -  6        Record name   "ATOM  "
 7 - 11        Integer       serial       Atom  serial number.
13 - 16        Atom          name         Atom name.
17             Character     altLoc       Alternate location indicator.
18 - 20        Residue name  resName      Residue name.
22             Character     chainID      Chain identifier.
23 - 26        Integer       resSeq       Residue sequence number.
27             AChar         iCode        Code for insertion of residues.
31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
55 - 60        Real(6.2)     occupancy    Occupancy.
61 - 66        Real(6.2)     tempFactor   Temperature  factor.
77 - 78        LString(2)    element      Element symbol, right-justified.
79 - 80        LString(2)    charge       Charge  on the atom.
"""

def makePdb(var,  code=None):
  
  if not code:
    code = 'PDB'
  
  lines = []
  add = lines.append
  add('REMARK 600')
  add('REMARK 600 HETEROGEN')
  add('REMARK 600 Generated by CcpNmr ChemBuild')
  add('REMARK 600 Compound name: %s' % var.compound.name)
  add('REMARK 600 Molecular formula: %s' % var.getMolFormula())
  proton, link, stereo = var.descriptor
  add('REMARK 600 Protonation state: %s' % proton)
  add('REMARK 600 Polymer linking: %s' % (var.polyLink or 'none'))
  add('REMARK 600 Non-polymer links: %s' % link)
  add('REMARK 600 Stereo centres: %s' % stereo)  
  add('REMARK 600')
  
  atoms = [(a.name[:4],  a) for a in var.varAtoms if a.element != LINK]
   
  atoms.sort()
  atomDict = {}
  
  for i,  (name, atom) in enumerate(atoms):
    atomDict[atom] = i+1
    x, y, z = [xyz/50.0 for xyz in atom.coords]
    e = atom.element
    o = 1.0
    b = 20.0 # Big
    alc = ' '
    q = str(atom.charge)
    data = (HETATM, i+1, name, alc, code, 'A', 1, ' ', x, y, z, o, b, e, q)
    add(PDB_FORMAT % data)
  
  for i,  (name, atom) in enumerate(atoms):
    if not atom.bonds:
      continue
    
    line = 'CONECT%5.1d' % (i+1)
    
    otherAtoms = []
    for bond in atom.bonds:
      bondType = bond.bondType
      
      for atomB in bond.varAtoms:
        if atomB is not atom:
          otherAtoms.append(atomB)
          
          if bondType == 'double':
            otherAtoms.append(atomB)
          
          if bondType == 'triple':
            otherAtoms.append(atomB)
            otherAtoms.append(atomB)
    
    nums = [atomDict[a] for a in otherAtoms if a in atomDict]
    nums.sort()
    
    for num in nums:
      line += '%5.1d' % num
    
    add(line)
  
  add('END')
  
  return '\n'.join(lines)
  
def importPdb(fileName):
  
  fileObj = open(fileName,  'rU')
  compound = Compound(fileName)
  var = Variant(compound)
  compound.defaultVars.add(var)
  atomDict = {}
  bondDict = {}
  zMin = None
  zMax = None

  for line in fileObj:
    
    key = line[0:6].strip()
          
    if key in ('HETATM','ATOM'):
      serial    = line[6:11].strip()
      atomName  = line[12:16].strip()
      altLoc    = line[16:17]
      resName   = line[17:20].strip()
      chainId   = line[21:22].strip()
      seqCode   = int(line[22:26])
      insertCode = line[26:27]
      x         = float(line[30:38])
      y         = float(line[38:46])
      z         = float(line[46:54])
      occupancy = float(line[54:60].strip() or 0)
      bFactor   = float(line[60:66].strip() or 0)
      segId     = line[72:76].strip()
      elem      = line[76:78].strip()
      
      if not elem:
        elem = match(r'\d*([A-Z])', atomName).group(1)
      
      try:
        charge = int(line[78:80].strip() or 0)
      except ValueError:
        charge = 0
  
      if zMin is None:
        zMin = zMax = z
 
      elif z < zMin:
        zMin = z
 
      elif z > zMax:
        zMax = z
     
      x *= 50.0
      y *= 50.0
      z *= 50.0
      atom = Atom(compound, elem, atomName)
      
      varAtom = VarAtom(var, atom, coords=(x, y, z))
      
      if charge:
        varAtom.setCharge(charge,  autoVar=False)
      
      atomDict[serial] = varAtom
      compound.name = resName
    
    if key == 'CONECT':
      serial = line[6:11].strip()
      nums = line[12:80].strip().split()
      
      for num in nums:
        key = frozenset([serial, num])
        bondDict[key] = bondDict.get(key, 0) + 1
  
  # add bonds aromatics
  
  aromatics = set()
  for key in bondDict: 
    serialA, serialB = key
    n = bondDict[key]
    
    varAtomA = atomDict[serialA]
    varAtomB = atomDict[serialB]
      
    if varAtomA.freeValences and varAtomB.freeValences:
      
      if n <= 2:
        bondType = 'single'
      elif n <= 4:
        bondType = 'double'
      elif n <= 6:
        bondType = 'triple'
      elif n <= 8:
        bondType = 'single'
        aromatics.add(varAtomA)
        aromatics.add(varAtomB)
        
      Bond((varAtomA, varAtomB), bondType=bondType, autoVar=False)
  
  # set aromatics
  
  if aromatics:
    rings = var.getRings(aromatics)
    
    for varAtoms2 in rings:
      if varAtoms2 & aromatics == varAtoms2:
        AtomGroup(compound, varAtoms2, AROMATIC)
  
  compound.center((0,  0,  0))
  var.checkBaseValences()
  
  if (zMax-zMin) > 1e-4:
    var.deduceStereo()
  
  return compound
